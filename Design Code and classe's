Design Code:

module spi ( // define SPI 
input clk, newd, rst, // newd = new data. The input can be "0" or "1" logi. 
input [11:0] din, // 12-bit wide bus
output reg sclk, cs, mosi // cs = what chip selected. the usage of clk is to initiate the system, and the usage of sclk is 
synchronizing the data transfer between the SPI master and slave devices.
    );
  
  typedef enum bit [1:0] {idle = 2'b00, enable = 2'b01, send = 2'b10, comp = 2'b11 } state_type; // current state of SPI module.
  state_type state = idle;
  
  int countc = 0; // declared to keep track of internal counts used for clock generation. This variable is used to keep track of the count for generating the sclk signal. 
  It is incremented on every clock cycle (posedge clk) until it reaches a certain value. 
 
  //// generation of sclk // clk is the main input clock signal to the module, 
 while sclk is an output signal generated within the module for serial clock synchronization purposes in SPI communication.
 always@(posedge clk) // Change of status every positive clock. 
  begin
    if(rst == 1'b1) begin
      countc <= 0; // used to initialize or reset the counter to zero before it starts counting.
      sclk <= 1'b0;
    end
    else begin 
      if(countc < 50 )
          countc <= countc + 1; // add 1 to the count until it get's to 50 counts. 
      else
          begin
          countc <= 0;
          sclk <= ~sclk; // ~ flips the value of sclk. If sclk is 1, then ~sclk will be 0, and if sclk is 0, then ~sclk will be 1. 
          This effectively toggles the signal between its current state and its complement.
          end
    end
  end
  
  ////// state machine
    reg [11:0] temp; // register with 12-bit.
    
  always@(posedge sclk) / always block to initiate positive edge for the clock. if posedge was negedge, then the clock was initiate in the negate edge.
  begin
    if(rst == 1'b1) begin 
      cs <= 1'b1; // Setting it to 1 typically means that no slave device is selected.
      mosi <= 1'b0; // It sets the initial value of mosi to 0 during a reset condition.
    end
    else begin
     case(state)
         idle:
             begin
               if(newd == 1'b1) begin // "high" indicating new data to be transmitted.
                 state <= send;
                 temp <= din; 
                 cs <= 1'b0; //  This line sets the cs signal to 0, selecting the slave device for communication.
               end
               else begin
                 state <= idle; // This line sets the state variable to idle, indicating that the SPI module remains in the idle state.
                 temp <= 8'h00;
               end
             end
                         
       send : begin
         if(count <= 11) begin
           mosi <= temp[count]; /////sending lsb first
           count <= count + 1;
         end
         else
             begin
               count <= 0;
               state <= idle;
               cs <= 1'b1;
               mosi <= 1'b0;
             end
       end
                  
      default : state <= idle; 
       
   endcase
  end 
 end
  
endmodule

///////////////////////////

interface spi_if; // interface provides a standardized way to define the signals and their characteristics for communication between modules.
a module represents a self-contained unit of hardware with its own internal logic and behavior, 
while an interface defines a set of signals and properties that facilitate communication between modules or entities.
Modules contain both the interface (input/output ports) and the internal logic,
whereas interfaces are focused on specifying the communication protocol and characteristics of the signals used for inter-module communication.

  logic clk;
  logic newd;
  logic rst;
  logic [11:0] din;
  logic sclk;
  logic cs;
  logic mosi;
  
endinterface

Testbench Code:

////////////////Transaction Class
class transaction;
  
  rand bit newd;
  rand bit [11:0] din;
  bit cs;
  bit mosi;
  
  function void display (input string tag);
    $display("[%0s] : DATA_NEW : %0b DIN : %0d CS : %b MOSI : %0b ", tag, newd, din, cs, mosi);    
  endfunction
  
  function transaction copy();
    copy = new();
    copy.newd = this.newd;
    copy.din = this.din;
    copy.cs = this.cs;
    copy.mosi = this.mosi;
  endfunction
  
endclass

/*
module tb;
  transaction tr;
  
  
  initial begin
    tr = new();
    tr.display("TOP");
    
  end
  
  
endmodule
 
*/
